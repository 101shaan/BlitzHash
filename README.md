# BlitzHash

**High-throughput non-cryptographic hash function for performance demonstrations.**

⚠️ **WARNING: BlitzHash is NOT cryptographically secure. This is a performance demonstration only. Do not use for security-critical applications.**

## Overview

BlitzHash is a fast, non-cryptographic hash function designed to showcase throughput optimization on modern hardware. It uses 64-bit multiply-rotate-XOR mixing for high instruction-level parallelism and demonstrates both single-threaded and parallel hashing performance.

**Key Features:**
- 32-byte (256-bit) output
- Streaming API for large files
- Parallel hashing with Rayon
- Comprehensive benchmark suite
- Fair comparison against SHA-256

## Quick Start

### Build

```bash
# Standard build
cargo build --release

# Maximum performance (use your CPU's features)
RUSTFLAGS="-C target-cpu=native -C opt-level=3" cargo build --release
```

### Run Benchmark

```bash
# Default: 100 MB random data, 8 threads
cargo run --release --bin bench

# Custom file
cargo run --release --bin bench -- --file /path/to/file

# Custom size and threads
cargo run --release --bin bench -- --size 1000000000 --threads 16

# All options
cargo run --release --bin bench -- \
  --size 100000000 \    # 100 MB
  --chunk 65536 \       # 64 KB chunks
  --threads 8 \         # 8 parallel threads
  --seed 42 \           # Hash seed
  --repeat 3            # Number of runs
```

## Design Choices

### Mixing Strategy

BlitzHash uses a four-state parallel mixing design:

1. **64-bit chunks**: Native word size for modern CPUs
2. **Multiply-rotate-XOR chains**: High throughput operations that pipeline well
3. **Four parallel states**: Allows instruction-level parallelism
4. **Constants**: Chosen to avoid algebraic patterns (primes with good bit distribution)

### Why It's Fast (But Not Secure)

**Speed advantages:**
- Simple operations (no S-boxes, minimal branches)
- Excellent CPU pipelining and instruction-level parallelism
- 64-bit arithmetic native on modern hardware
- Parallel chunking for multi-core scaling

**Security trade-offs:**
- No cryptanalysis-resistant design
- Simpler mixing than cryptographic hashes
- Not designed against collision or preimage attacks
- Optimized for throughput, not security margins

### Performance Expectations

On modern hardware (6-8 core CPU with AVX2):

- **SHA-256 baseline**: ~200-1200 MB/s (varies by implementation)
- **BlitzHash single-thread**: Target 2-4× SHA-256 baseline
- **BlitzHash parallel**: Near-linear scaling with cores (4-8× baseline on 8 cores)

*Note: Actual performance depends on CPU, memory bandwidth, and compiler optimizations.*

## Reproducing Benchmarks

### Requirements
- Rust stable (1.70+)
- Python 3.8+ (for visualization)
- `matplotlib` and `pandas` (for plots)

### Exact Steps

```bash
# 1. Clone and build with optimizations
git clone <repo>
cd blitzhash
RUSTFLAGS="-C target-cpu=native -C opt-level=3" cargo build --release

# 2. Run tests
cargo test --release

# 3. Run benchmark (generates bench_results.csv)
cargo run --release --bin bench -- --size 100000000 --threads 8 --repeat 3

# 4. Generate plots
python viz/plot_results.py

# 5. View results
open bench_plot.png  # or xdg-open on Linux
```

### Benchmark Protocol

**Our methodology:**
- Always use `--release` builds
- Warm-up run before timing
- 3 timed runs, report median
- Fair comparison: same chunk sizes for SHA-256 and BlitzHash
- Single-threaded comparison uses identical streaming logic
- Parallel comparison shows multi-core scaling

**Measurement:**
- Clock: `std::time::Instant` (monotonic)
- MB/s calculation: `(bytes / 1_000_000) / elapsed_seconds`
- CSV output includes: algorithm, threads, chunk size, total size, seed, MB/s, timestamp

## File Structure

```
blitzhash/
├── Cargo.toml          # Dependencies and build config
├── README.md           # This file
├── src/
│   ├── lib.rs          # Core BlitzHash implementation
│   └── bin/
│       └── bench.rs    # Benchmark harness and CLI
├── viz/
│   └── plot_results.py # Generates charts from CSV
└── bench_results.csv   # Generated by benchmarks
```

## API Usage

```rust
use blitzhash::{blitz_hash, BlitzState};

// One-shot hashing
let data = b"Hello, world!";
let digest = blitz_hash(0, data);
println!("Hash: {}", hex::encode(digest));

// Streaming API
let mut hasher = BlitzState::new(42);
hasher.absorb(b"part 1");
hasher.absorb(b"part 2");
let digest = hasher.finalize();

// Parallel hashing
let large_data = vec![0u8; 100_000_000];
let digest = blitzhash::blitz_hash_parallel(0, &large_data, 8);
```

## Testing

```bash
# Run unit tests
cargo test

# Run with output
cargo test -- --nocapture
```

## Future Optimizations

**Planned (not implemented in baseline):**
- [ ] AVX2 SIMD intrinsics (runtime detection)
- [ ] Memory-mapped I/O for zero-copy large files
- [ ] Assembly-optimized mixing function
- [ ] GPU kernel (OpenCL/CUDA) for massive parallelism
- [ ] WASM build for browser demo

## License

MIT License - see LICENSE file

## Showcase Slide

**Title:** BlitzHash - Speed Without Security

**Pitch:** A demonstration hash function that trades cryptographic security for raw throughput, achieving 4-8× SHA-256 speed on modern hardware.

**Key Points:**
- Simple 64-bit multiply-rotate-XOR mixing for maximum CPU throughput
- Parallel hashing with near-linear scaling across cores
- **NOT cryptographically secure** - performance demo only
- Reproducible benchmarks with fair SHA-256 baseline comparison

**Results:** On 8-core CPU: ~4000+ MB/s parallel vs ~800 MB/s SHA-256 baseline

**Limitation:** No security guarantees - do not use for passwords, signatures, or any security-critical application.

---

## Contributing

This is a demonstration project. Contributions welcome for:
- Performance improvements
- Additional benchmarks
- Visualization enhancements
- Documentation improvements

## Contact

For questions about cryptographic hash functions, see [NIST standards](https://csrc.nist.gov/projects/hash-functions).

For questions about this demo, open an issue.
